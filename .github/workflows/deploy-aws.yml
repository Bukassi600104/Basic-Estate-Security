name: Deploy (AWS ECS + RDS)

on:
  workflow_dispatch:
    inputs:
      image_tag:
        description: "Docker image tag (e.g. prod, sha, v1)"
        required: true
        default: "prod"
      desired_count:
        description: "ECS desired task count"
        required: true
        default: "1"
      run_migrations:
        description: "Run Prisma migrate deploy via ECS run-task"
        required: true
        default: "true"
      run_seed:
        description: "Run seed via ECS run-task (optional env must be set)"
        required: true
        default: "false"

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: eu-north-1
  PROJECT_NAME: basic-security

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Resolve app secrets name
        run: |
          if [ -n "${{ secrets.APP_SECRETS_NAME }}" ]; then
            echo "APP_SECRETS_NAME=${{ secrets.APP_SECRETS_NAME }}" >> $GITHUB_ENV
          else
            echo "APP_SECRETS_NAME=prod/app-secrets" >> $GITHUB_ENV
          fi

      - uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Preflight: verify required app secrets
        run: |
          echo "Checking Secrets Manager secret: ${APP_SECRETS_NAME}"
          SECRET_STRING=$(aws secretsmanager get-secret-value --secret-id "${APP_SECRETS_NAME}" --query SecretString --output text)
          if [ -z "$SECRET_STRING" ] || [ "$SECRET_STRING" = "None" ]; then
            echo "SecretString is empty for ${APP_SECRETS_NAME}" >&2
            exit 1
          fi

          # Ensure required JSON keys exist (avoid ECS task start failures).
          echo "$SECRET_STRING" | jq -e '.AUTH_JWT_SECRET and (.AUTH_JWT_SECRET|length>=20)' >/dev/null
          echo "$SECRET_STRING" | jq -e '.TELEGRAM_BOT_TOKEN and (.TELEGRAM_BOT_TOKEN|length>=1)' >/dev/null
          echo "$SECRET_STRING" | jq -e '.TELEGRAM_WEBHOOK_SECRET and (.TELEGRAM_WEBHOOK_SECRET|length>=16)' >/dev/null

          echo "Secrets preflight OK"

      - name: Compute image URI
        id: img
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "account_id=$ACCOUNT_ID" >> $GITHUB_OUTPUT
          echo "image_uri=$ACCOUNT_ID.dkr.ecr.${AWS_REGION}.amazonaws.com/${PROJECT_NAME}:${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT

      - name: Terraform init
        working-directory: infra
        run: |
          cat > backend.hcl <<EOF
          bucket         = "${TF_STATE_BUCKET}"
          key            = "${TF_STATE_KEY}"
          region         = "${AWS_REGION}"
          dynamodb_table = "${TF_STATE_DDB_TABLE}"
          encrypt        = true
          EOF
          terraform init -backend-config=backend.hcl

        env:
          TF_STATE_BUCKET: ${{ secrets.TF_STATE_BUCKET }}
          TF_STATE_DDB_TABLE: ${{ secrets.TF_STATE_DDB_TABLE }}
          TF_STATE_KEY: ${{ env.PROJECT_NAME }}/terraform.tfstate

      - name: Import existing ECR repository (if any)
        working-directory: infra
        env:
          TF_VAR_container_image: ${{ steps.img.outputs.image_uri }}
          TF_VAR_desired_count: 0
          TF_VAR_project_name: ${{ env.PROJECT_NAME }}
          TF_VAR_aws_region: ${{ env.AWS_REGION }}
          TF_VAR_app_secrets_name: ${{ env.APP_SECRETS_NAME }}
        run: |
          if aws ecr describe-repositories --repository-names "${PROJECT_NAME}" >/dev/null 2>&1; then
            terraform state list 2>/dev/null | grep -q '^aws_ecr_repository\.app$' \
              || terraform import -no-color aws_ecr_repository.app "${PROJECT_NAME}"
          fi

      - name: Terraform apply (bootstrap, desired_count=0)
        working-directory: infra
        env:
          TF_VAR_container_image: ${{ steps.img.outputs.image_uri }}
          TF_VAR_desired_count: 0
          TF_VAR_project_name: ${{ env.PROJECT_NAME }}
          TF_VAR_aws_region: ${{ env.AWS_REGION }}
          TF_VAR_app_secrets_name: ${{ env.APP_SECRETS_NAME }}
        run: |
          terraform apply -auto-approve

      - name: Login to ECR
        id: ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push image
        run: |
          docker build -t "${{ steps.img.outputs.image_uri }}" .
          docker push "${{ steps.img.outputs.image_uri }}"

      - name: Terraform apply
        working-directory: infra
        env:
          TF_VAR_container_image: ${{ steps.img.outputs.image_uri }}
          TF_VAR_desired_count: ${{ github.event.inputs.desired_count }}
          TF_VAR_project_name: ${{ env.PROJECT_NAME }}
          TF_VAR_aws_region: ${{ env.AWS_REGION }}
          TF_VAR_app_secrets_name: ${{ env.APP_SECRETS_NAME }}
        run: |
          terraform apply -auto-approve

      - name: Fetch Terraform outputs
        id: tf
        working-directory: infra
        run: |
          jq --version
          echo "cluster_name=$(terraform output -raw ecs_cluster_name)" >> $GITHUB_OUTPUT
          echo "task_def_arn=$(terraform output -raw ecs_task_definition_arn)" >> $GITHUB_OUTPUT
          echo "sg_id=$(terraform output -raw ecs_security_group_id)" >> $GITHUB_OUTPUT
          SUBNETS=$(terraform output -json public_subnet_ids | jq -r '.[]' | paste -sd ',' -)
          echo "subnets=$SUBNETS" >> $GITHUB_OUTPUT
          echo "alb_dns=$(terraform output -raw alb_dns_name)" >> $GITHUB_OUTPUT
          echo "cloudfront_domain=$(terraform output -raw cloudfront_domain_name)" >> $GITHUB_OUTPUT

      - name: Run Prisma migrations (ECS one-off)
        if: ${{ github.event.inputs.run_migrations == 'true' }}
        run: |
          aws ecs run-task \
            --cluster "${{ steps.tf.outputs.cluster_name }}" \
            --task-definition "${{ steps.tf.outputs.task_def_arn }}" \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[${{ steps.tf.outputs.subnets }}],securityGroups=[${{ steps.tf.outputs.sg_id }}],assignPublicIp=ENABLED}" \
            --overrides '{"containerOverrides":[{"name":"app","command":["npm","run","db:migrate:deploy"]}]}'

      - name: Run seed (ECS one-off)
        if: ${{ github.event.inputs.run_seed == 'true' }}
        run: |
          aws ecs run-task \
            --cluster "${{ steps.tf.outputs.cluster_name }}" \
            --task-definition "${{ steps.tf.outputs.task_def_arn }}" \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[${{ steps.tf.outputs.subnets }}],securityGroups=[${{ steps.tf.outputs.sg_id }}],assignPublicIp=ENABLED}" \
            --overrides '{"containerOverrides":[{"name":"app","command":["npm","run","db:seed"]}]}'

      - name: Show public URL + webhook hint
        run: |
          echo "CloudFront URL: https://${{ steps.tf.outputs.cloudfront_domain }}/"
          echo "Telegram webhook: https://${{ steps.tf.outputs.cloudfront_domain }}/api/telegram/webhook"

      - name: Smoke check: ALB + CloudFront health
        run: |
          set -e
          ALB_URL="http://${{ steps.tf.outputs.alb_dns }}/api/healthz"
          CF_URL="https://${{ steps.tf.outputs.cloudfront_domain }}/api/healthz"

          echo "Checking ALB health: $ALB_URL"
          curl -fsS "$ALB_URL" | head -c 200 || (echo "ALB health check failed" >&2; exit 1)

          echo "Checking CloudFront health: $CF_URL"
          curl -fsS "$CF_URL" | head -c 200 || (echo "CloudFront health check failed" >&2; exit 1)
